// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is generated by tool.
//     Runtime Version : 0.1.0
//  
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using Kae.StateMachine;
using Kae.DomainModel.Csharp.Framework;

namespace ProcessManagement
{
    partial class DomainClassREQStateMachine
    {
        protected void ActionWaitingForResourceAssigned(string ResourceName, string Step1Command, string Step2Command, string Step3Command)
        {
            // Action Description on Model as a reference.

            //  1 : SELECT ANY resource FROM INSTANCES OF RES WHERE SELECTED.Name == rcvd_evt.ResourceName;
            //  2 : IF NOT_EMPTY resource
            //  3 : 	RELATE SELF TO resource ACROSS R8;
            //  4 : 	SELECT ONE resourceAssigner RELATED BY resource->RA[R6];
            //  5 : 	GENERATE RA1:'Request Resource' TO resourceAssigner;
            //  6 : END IF;

            // Line : 1
            var resource = (DomainClassRES)(instanceRepository.GetDomainInstances("RES").Where(selected => ((((DomainClassRES)selected).Attr_Name == ResourceName))).FirstOrDefault());

            // Line : 2
            if (resource != null)
            {
                // Line : 3
                // SELF - R8 -> resource;
                target.LinkR8IsRequesting(resource, changedStates);

                // Line : 4
                var resourceAssigner = resource.LinkedR6();

                // Line : 5
                DomainClassRAStateMachine.RA1_RequestResource.Create(receiver:resourceAssigner, sendNow:true);

            }


        }

        protected void ActionProcessing()
        {
            // Action Description on Model as a reference.



        }

        protected void ActionDone()
        {
            // Action Description on Model as a reference.

            //   1 : SELECT ONE process RELATED BY SELF->P[R1];
            //   2 : SELECT ONE processStep RELATED BY process->PS[R3.'first step'];
            //   3 : UNRELATE process FROM processStep ACROSS R3;
            //   4 : WHILE NOT_EMPTY processStep
            //   5 : 	SELECT ONE iWork RELATED BY processStep->IntermediateWork[R5.'successor'];
            //   6 : 	SELECT ONE nextStep RELATED BY iWork->PS[R5.'successor'];
            //   7 : 	UNRELATE processStep FROM nextStep ACROSS R5.'successor' USING iWork;
            //   8 : 	DELETE OBJECT INSTANCE iWork;
            //   9 : 	processStep = nextStep;
            //  10 : END WHILE;
            //  11 : SELECT MANY processSpecSet RELATED BY process->PS[R2];
            //  12 : FOR EACH processSpec IN processSpecSet
            //  13 : 	SELECT ONE orderSpec RELATED BY processSpec->OS[R4];
            //  14 : 	UNRELATE processSpec FROM orderSpec ACROSS R4;
            //  15 : 	UNRELATE process FROM processSpec ACROSS R2;
            //  16 : 	DELETE OBJECT INSTANCE processStep;
            //  17 : END FOR;
            //  18 : SELECT ONE resource RELATED BY process->RES[R1.'is user of'];
            //  19 : UNRELATE SELF FROM resource ACROSS R1 USING process;

            // Line : 1
            var process = target.LinkedR1OtherIsUserOf();

            // Line : 2
            var processStep = process.LinkedR3FirstStep();

            // Line : 3
            // Unrelate process From processStep Across R3
            process.UnlinkR3FirstStep(processStep, changedStates);

            // Line : 4
            while (processStep != null)
            {
            }

            // Line : 11
            var processSpecSet = process.LinkedR2() as List<DomainClassPS>;

            // Line : 12
            foreach (var processSpec in processSpecSet)
            {
                // Line : 13
                var orderSpec = processSpec.LinkedR4();

                // Line : 14
                // Unrelate processSpec From orderSpec Across R4
                processSpec.UnlinkR4(orderSpec, changedStates);

                // Line : 15
                // Unrelate process From processSpec Across R2
                processSpec.UnlinkR2(process, changedStates);

                // Line : 16
                processStep.DeleteInstance(changedStates);
            }

            // Line : 18
            var resource = process.LinkedR1OtherIsUserOf();

            // Line : 19
            // Unrelate SELF From resource Across R1 Using process
            process.UnlinkR1(target,resource);


        }

    }
}
